{
    "contents" : "#' Efficient Frontier function\n#' \n#' Takes in any portfolio of stocks return and optimizes it using the Efficient Frontier \n#' @param Data A portfolio with its parameters to be optimize \n#' @return The allocation percent for the portfolio\n#' @import quadprog \n#' @export\n \neff_frontier <- function (Data){\n  # return argument should be a m x n matrix with one column per security\n  # short argument is whether short-selling is allowed; default is no (short\n  # selling prohibited)max_allocation is the maximum % allowed for any one\n  # security (reduces concentration) risk_premium_up is the upper limit of the\n  # risk premium modeled (see for loop below) and risk_increment is the\n  # increment (by) value used in the for loop\n  \n  #Convert the json data to numeric matrix\n  data <- data.matrix(Data$data,rownames.force=TRUE) # Converts to data matrix\n  colNames <- rownames(data) # Gets the rows names\n  data <- as.data.frame(sapply(data, as.numeric)) # Convert all value from char to numeric\n  names(data)<-colNames # Add the col names \n  data <- data.matrix(data) # Convert the data frame to a numeric matrix for processing\n  \n  #find and remove all the dimensions\n  dimensionCount<-length(which(Data$type == 'dimension')) # Count # of dimensions\n    \n  returns<-data[,dimensionCount*-1] # remove dimensions from matrix\n  \n  #extract, convert and save all parameters\n  short<-as.numeric(Data$param$short)\n  max_allocation<-as.numeric(Data$param$max_allocation)\n  risk_premium_up<-as.numeric(Data$param$risk_premium_up)\n  risk_increment<-as.numeric(Data$param$risk_increment)\n  \n  # Let's Optimize!\n  covariance <- cov(returns)\n  \n  n <- ncol(covariance)\n  \n  # Create initial Amat and bvec assuming only equality constraint\n  # (short-selling is allowed, no allocation constraints)\n  Amat <- matrix (1, nrow=n)\n  bvec <- 1\n  meq <- 1\n  \n  # Then modify the Amat and bvec if short-selling is prohibited\n  # 0 means no short-selling\n  # 1 means yes short-selling\n  if(short==0){\n    Amat <- cbind(1, diag(n))\n    bvec <- c(bvec, rep(0, n))\n  }\n  \n  # And modify Amat and bvec if a max allocation (concentration) is specified\n  if(!is.null(max_allocation)){\n    if(max_allocation > 1 | max_allocation <0){\n      stop(\"max_allocation must be greater than 0 and less than 1\")\n    }\n    if(max_allocation * n < 1){\n      stop(\"Need to set max_allocation higher; not enough assets to add to 1\")\n    }\n    Amat <- cbind(Amat, -diag(n))\n    bvec <- c(bvec, rep(-max_allocation, n))\n  }\n  \n  # Calculate the number of loops\n  loops <- risk_premium_up / risk_increment + 1\n  loop <- 1\n  \n  # Initialize a matrix to contain allocation and statistics\n  # This is not necessary, but speeds up processing and uses less memory\n  eff <- matrix(nrow=loops, ncol=n+3)\n  # Now I need to give the matrix column names\n  colnames(eff) <- c(colnames(returns), \"Std.Dev\", \"Exp.Return\", \"sharpe\")\n  \n  # Loop through the quadratic program solver\n  for (i in seq(from=0, to=risk_premium_up, by=risk_increment)){\n    dvec <- colMeans(returns) * i # This moves the solution along the EF\n    sol <- solve.QP(covariance, dvec=dvec, Amat=Amat, bvec=bvec, meq=meq)\n    eff[loop,\"Std.Dev\"] <- sqrt(sum(sol$solution*colSums((covariance*sol$solution))))\n    eff[loop,\"Exp.Return\"] <- as.numeric(sol$solution %*% colMeans(returns))\n    eff[loop,\"sharpe\"] <- eff[loop,\"Exp.Return\"] / eff[loop,\"Std.Dev\"]\n    eff[loop,1:n] <- sol$solution\n    loop <- loop+1\n  }\n  \n  eff <-as.data.frame(eff)\n  \n  #Asuumption: check if the more then one result is max for Sharpe then take the first one\n  if (nrow(eff[eff$sharpe==max(eff$sharpe),])>1) {\n    optimized<-eff[eff$sharpe==max(eff$sharpe),!(names(eff) %in% c(\"Std.Dev\", \"Exp.Return\", \"sharpe\"))]\n    optimized<-optimized[1,]\n  } else {\n    optimized<-eff[eff$sharpe==max(eff$sharpe),!(names(eff) %in% c(\"Std.Dev\", \"Exp.Return\", \"sharpe\"))]\n  }\n  \n  return(optimized)\n}",
    "created" : 1415581249841.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1157105087",
    "id" : "70937050",
    "lastKnownWriteTime" : 1415898258,
    "path" : "~/GitHub/r-pkg/qEfficientFrontier/R/qEfficientFrontier.R",
    "project_path" : "R/qEfficientFrontier.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}